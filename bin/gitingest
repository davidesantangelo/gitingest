#!/usr/bin/env ruby
# frozen_string_literal: true

require "optparse"
require "gitingest"

options = {}
parser = OptionParser.new do |opts|
  opts.banner = "Usage: gitingest [OPTIONS]"
  opts.separator ""
  opts.separator "Options:"

  opts.on("-r", "--repository REPO", "GitHub repository (username/repo) [Required]") do |repo|
    options[:repository] = repo
  end

  opts.on("-t", "--token TOKEN", "GitHub personal access token") do |token|
    options[:token] = token
  end

  opts.on("-o", "--output FILE", "Output file for the prompt") do |file|
    options[:output_file] = file
  end

  opts.on("-b", "--branch BRANCH", "Repository branch") do |branch|
    options[:branch] = branch
  end

  opts.on("-e", "--exclude PATTERN", "File patterns to exclude (comma separated)") do |pattern|
    options[:exclude] = pattern.split(",")
  end

  opts.on("-q", "--quiet", "Disable all output except errors") do
    options[:quiet] = true
  end

  opts.on("-v", "--verbose", "Enable verbose output") do
    options[:verbose] = true
  end

  opts.on("-h", "--help", "Show this help message") do
    puts opts
    exit
  end
end

begin
  parser.parse!

  if options[:repository].nil?
    puts "Error: Repository option is required"
    puts parser
    exit 1
  end

  generator = Gitingest::Generator.new(options)
  generator.run
rescue OptionParser::InvalidOption => e
  puts "Error: #{e.message}"
  puts parser
  exit 1
rescue StandardError => e
  puts "Error: #{e.message}"
  exit 1
end
